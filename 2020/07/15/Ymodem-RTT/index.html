<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ymodem RTT - zZHongyu的博客</title><meta description="代码阅读：RTT基于Ymodem协议传输文件的实现     核心层 对应用API handshake trans fin 基础函数   应用层（OTA应用） on_begin on_data ota      核心层核心层实现于”Utilities&amp;#x2F;ymodom.c”，主要完成了基于Ymodem协议的握手和收发业务，向上层应用提供了收发API，需要提供收发的控制器，端口设备，端口开启的参数配置，"><meta property="og:type" content="blog"><meta property="og:title" content="Ymodem RTT"><meta property="og:url" content="http://yoursite.com/2020/07/15/Ymodem-RTT/"><meta property="og:site_name" content="zZHongyu的博客"><meta property="og:description" content="代码阅读：RTT基于Ymodem协议传输文件的实现     核心层 对应用API handshake trans fin 基础函数   应用层（OTA应用） on_begin on_data ota      核心层核心层实现于”Utilities&amp;#x2F;ymodom.c”，主要完成了基于Ymodem协议的握手和收发业务，向上层应用提供了收发API，需要提供收发的控制器，端口设备，端口开启的参数配置，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:published_time" content="2020-07-15T12:34:02.000Z"><meta property="article:modified_time" content="2020-07-15T13:05:07.284Z"><meta property="article:author" content="朱洪煜"><meta property="article:tag" content="Ymodem"><meta property="article:tag" content="协议"><meta property="article:tag" content="文件传输"><meta property="article:tag" content="源码阅读"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/07/15/Ymodem-RTT/"},"headline":"zZHongyu的博客","image":["http://yoursite.com/img/og_image.png"],"datePublished":"2020-07-15T12:34:02.000Z","dateModified":"2020-07-15T13:05:07.284Z","author":{"@type":"Person","name":"朱洪煜"},"description":"代码阅读：RTT基于Ymodem协议传输文件的实现     核心层 对应用API handshake trans fin 基础函数   应用层（OTA应用） on_begin on_data ota      核心层核心层实现于”Utilities&#x2F;ymodom.c”，主要完成了基于Ymodem协议的握手和收发业务，向上层应用提供了收发API，需要提供收发的控制器，端口设备，端口开启的参数配置，"}</script><link rel="canonical" href="http://yoursite.com/2020/07/15/Ymodem-RTT/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="zZHongyu的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/gerald0057"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-15T12:34:02.000Z" title="2020-07-15T12:34:02.000Z">2020-07-15</time><span class="level-item">37 分钟 读完 (大约 5620 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Ymodem RTT</h1><div class="content"><blockquote>
<p>代码阅读：RTT基于Ymodem协议传输文件的实现</p>
</blockquote>
<!-- toc -->

<ul>
<li><a href="#核心层">核心层</a><ul>
<li><a href="#对应用api">对应用API</a></li>
<li><a href="#handshake">handshake</a></li>
<li><a href="#trans">trans</a></li>
<li><a href="#fin">fin</a></li>
<li><a href="#基础函数">基础函数</a></li>
</ul>
</li>
<li><a href="#应用层ota应用">应用层（OTA应用）</a><ul>
<li><a href="#on_begin">on_begin</a></li>
<li><a href="#on_data">on_data</a></li>
<li><a href="#ota">ota</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="核心层">核心层</span></h2><p>核心层实现于”Utilities/ymodom.c”，主要完成了基于Ymodem协议的握手和收发业务，向上层应用提供了收发API，需要提供收发的控制器，端口设备，端口开启的参数配置，第一个数据块的处理实现函数on_begin，之后数据块的处理实现函数on_data，可选的收发结束处理函数实现on_end，以及握手的timeout设置；</p>
<a id="more"></a>

<h3><span id="对应用api">对应用API</span></h3><h4><span id="recv">recv</span></h4><blockquote>
<p>recv_on_device</p>
</blockquote>
<p>该函数从通讯端口以Ymodom协议接收数据块，为应用层接收通讯设备返回数据时调用的唯一接口；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rt_err_t</span> <span class="title">rym_recv_on_device</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct rym_ctx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">rt_device_t</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">rt_uint16_t</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_begin,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_data,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_end,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> handshake_timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> res;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 由于要使用Ymodem协议传输数据，需要独占该设备，因此要修改该通讯设备原始的接收跳转函数</span></span><br><span class="line"><span class="comment">     * 所以为了在传输完成后恢复该通讯设备的原始功能，需要先保存原始的接收跳转函数地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> (*odev_rx_ind)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">/* flag定义了以何种方式使用该通讯设备 */</span></span><br><span class="line">    <span class="keyword">rt_uint16_t</span> odev_flag;</span><br><span class="line">    <span class="keyword">int</span> int_lvl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化传入的参数，将其与该空间内的全局变量_rym_the_ctx挂钩 */</span></span><br><span class="line">    RT_ASSERT(_rym_the_ctx == <span class="number">0</span>);</span><br><span class="line">    _rym_the_ctx = ctx;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;on_begin = on_begin;</span><br><span class="line">    ctx-&gt;on_data  = on_data;</span><br><span class="line">    ctx-&gt;on_end   = on_end;</span><br><span class="line">    ctx-&gt;dev      = dev;</span><br><span class="line">    <span class="comment">/* 初始化通讯信号量用于接收不定长的数据 */</span></span><br><span class="line">    rt_sem_init(&amp;ctx-&gt;sem, <span class="string">"rymsem"</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line">	<span class="comment">/* 保存该设备原始的跳转函数rx_indicate的地址，以供后续恢复 */</span></span><br><span class="line">    odev_rx_ind = dev-&gt;rx_indicate;</span><br><span class="line">    <span class="comment">/* 修改接收跳转函数，防止设备正在（将要）被访问，屏蔽中断 */</span></span><br><span class="line">    int_lvl = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 重定向为Ymodem传输时需要的跳转函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(dev, _rym_rx_ind);</span><br><span class="line">    <span class="comment">/* 保存原始的通讯端口配置flag参数 */</span></span><br><span class="line">    odev_flag = dev-&gt;open_flag;</span><br><span class="line">    <span class="comment">/* 在设备处于流模式，输出的字符是"\n"（0x0A）时，自动在前面输出一个"\r"，该功能有可能会破坏Ymodem协议，因此禁用 */</span></span><br><span class="line">    dev-&gt;open_flag &amp;= ~RT_DEVICE_FLAG_STREAM;</span><br><span class="line">    <span class="comment">/* 通讯设备配置完毕，启用中断 */</span></span><br><span class="line">    rt_hw_interrupt_enable(int_lvl);</span><br><span class="line">	<span class="comment">/* 开启通讯端口设备 */</span></span><br><span class="line">    res = rt_device_open(dev, oflag);</span><br><span class="line">    <span class="keyword">if</span> (res != RT_EOK)</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">	<span class="comment">/* 给定传输控制器和握手时间，接受数据 */</span></span><br><span class="line">    res = _rym_do_recv(ctx, handshake_timeout);</span><br><span class="line">	<span class="comment">/* 数据接收完毕，接收状态和错误状态分别保存在res和ctx内，关闭通讯设备 */</span></span><br><span class="line">    rt_device_close(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设备开启失败或者数据接受完毕 */</span></span><br><span class="line">__exit:</span><br><span class="line">    <span class="comment">/* no rx_ind should be called before the callback has been fully detached.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    int_lvl = rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 信号量已失去作用，将其从线程通讯空间内分离 */</span></span><br><span class="line">    rt_sem_detach(&amp;ctx-&gt;sem);</span><br><span class="line">	<span class="comment">/* 恢复原始的设备flag参数 */</span></span><br><span class="line">    dev-&gt;open_flag = odev_flag;</span><br><span class="line">    <span class="comment">/* 恢复原始的接收跳转函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(dev, odev_rx_ind);</span><br><span class="line">    rt_hw_interrupt_enable(int_lvl);</span><br><span class="line">    <span class="comment">/* 复位全局指针，防止危险操作 */</span></span><br><span class="line">    _rym_the_ctx = RT_NULL;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_do_recv</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_recv(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">int</span> handshake_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> err;</span><br><span class="line">	<span class="comment">/* 复位控制器状态 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_NONE;</span><br><span class="line">	<span class="comment">/* 至少保证一个大包的空间已被成功申请 */</span></span><br><span class="line">    ctx-&gt;buf = rt_malloc(_RYM_STX_PKG_SZ);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;buf == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> -RT_ENOMEM;</span><br><span class="line">	<span class="comment">/* 与发送端握手 */</span></span><br><span class="line">    err = _rym_do_handshake(ctx, handshake_timeout);</span><br><span class="line">    <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">        <span class="comment">/* 握手失败，释放动态申请的内存 */</span></span><br><span class="line">        rt_free(ctx-&gt;buf);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 握手成功后，进入收发循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 执行传输任务 */</span></span><br><span class="line">        err = _rym_do_trans(ctx);</span><br><span class="line">        <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">            rt_free(ctx-&gt;buf);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 执行传输完成后任务 */</span></span><br><span class="line">        err = _rym_do_fin(ctx);</span><br><span class="line">        <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">            rt_free(ctx-&gt;buf);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 循环跳出 */</span></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;stage == RYM_STAGE_FINISHED)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    rt_free(ctx-&gt;buf);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="send">send</span></h4><blockquote>
<p>send_on_device</p>
</blockquote>
<p>该函数从通讯端口以Ymodom协议发送数据块，为应用层从通讯设备发送数据时调用的唯一接口；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rt_err_t</span> <span class="title">rym_send_on_device</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct rym_ctx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">rt_device_t</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">rt_uint16_t</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_begin,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_data,</span></span></span><br><span class="line"><span class="function"><span class="params">    rym_callback on_end,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> handshake_timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">rt_err_t</span> (*odev_rx_ind)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> odev_flag;</span><br><span class="line">    <span class="keyword">int</span> int_lvl;</span><br><span class="line"></span><br><span class="line">    RT_ASSERT(_rym_the_ctx == <span class="number">0</span>);</span><br><span class="line">    _rym_the_ctx = ctx;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;on_begin = on_begin;</span><br><span class="line">    ctx-&gt;on_data  = on_data;</span><br><span class="line">    ctx-&gt;on_end   = on_end;</span><br><span class="line">    ctx-&gt;dev      = dev;</span><br><span class="line">    rt_sem_init(&amp;ctx-&gt;sem, <span class="string">"rymsem"</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    odev_rx_ind = dev-&gt;rx_indicate;</span><br><span class="line">    int_lvl = rt_hw_interrupt_disable();</span><br><span class="line">    rt_device_set_rx_indicate(dev, _rym_rx_ind);</span><br><span class="line"></span><br><span class="line">    odev_flag = dev-&gt;open_flag;</span><br><span class="line">    dev-&gt;open_flag &amp;= ~RT_DEVICE_FLAG_STREAM;</span><br><span class="line">    rt_hw_interrupt_enable(int_lvl);</span><br><span class="line"></span><br><span class="line">    res = rt_device_open(dev, oflag);</span><br><span class="line">    <span class="keyword">if</span> (res != RT_EOK)</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给定传输控制器和握手时间，发送数据 */</span></span><br><span class="line">    res = _rym_do_send(ctx, handshake_timeout);</span><br><span class="line"></span><br><span class="line">    rt_device_close(dev);</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line"></span><br><span class="line">    int_lvl = rt_hw_interrupt_disable();</span><br><span class="line">    rt_sem_detach(&amp;ctx-&gt;sem);</span><br><span class="line"></span><br><span class="line">    dev-&gt;open_flag = odev_flag;</span><br><span class="line">    rt_device_set_rx_indicate(dev, odev_rx_ind);</span><br><span class="line">    rt_hw_interrupt_enable(int_lvl);</span><br><span class="line"></span><br><span class="line">    _rym_the_ctx = RT_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_do_send</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_send(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">int</span> handshake_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> err;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_NONE;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;buf = rt_malloc(_RYM_STX_PKG_SZ);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;buf == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> -RT_ENOMEM;</span><br><span class="line">	<span class="comment">/* Ymodem协议为接受端驱动型，发送时单次顺序执行 */</span></span><br><span class="line">    err = _rym_do_send_handshake(ctx, handshake_timeout);</span><br><span class="line">    <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">        rt_free(ctx-&gt;buf);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = _rym_do_send_trans(ctx);</span><br><span class="line">    <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">        rt_free(ctx-&gt;buf);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = _rym_do_send_fin(ctx);</span><br><span class="line">    <span class="keyword">if</span> (err != RT_EOK) &#123;</span><br><span class="line">        rt_free(ctx-&gt;buf);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_free(ctx-&gt;buf);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="handshake">handshake</span></h3><blockquote>
<p>_rym_do_handshake</p>
</blockquote>
<p>该函数用于Ymodem协议<strong>接收</strong>时的握手，该接收端不断发送代码C，同时等待发送端返回第一个包，接收并检测后交于应用层处理，处理无错误代表握手成功，执行接收任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_handshake(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">int</span> tm_sec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> rym_code code;</span><br><span class="line">    <span class="keyword">rt_size_t</span> i;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> recv_crc, cal_crc;</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz;</span><br><span class="line">    <span class="keyword">rt_tick_t</span> tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入连接等待建立状态 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_ESTABLISHING;</span><br><span class="line">    <span class="comment">/* 每隔一段时间发送代码C，代表等待建立通讯. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tm_sec; i++) &#123;</span><br><span class="line">        <span class="comment">/* 发送代码C */</span></span><br><span class="line">        _rym_putchar(ctx, RYM_CODE_C);</span><br><span class="line">        <span class="comment">/* 等待读取，每次等待RYM_CHD_INTV_TICK时间 */</span></span><br><span class="line">        code = _rym_read_code(ctx, RYM_CHD_INTV_TICK);</span><br><span class="line">        <span class="comment">/* 如果关键字为SOH，代表接收小包，设置接收长度为1+2+128+2Bytes */</span></span><br><span class="line">        <span class="keyword">if</span> (code == RYM_CODE_SOH) &#123;</span><br><span class="line">            data_sz = _RYM_SOH_PKG_SZ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果关键字为STX，代表接收大包，设置接收长度为1+2+1024+2Bytes */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code == RYM_CODE_STX) &#123;</span><br><span class="line">            data_sz = _RYM_STX_PKG_SZ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 经过tm_sec次循环，没有读到正确的关键字后退出for循环，代表传输timeout，返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (i == tm_sec) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_TMO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读到关键字，得到包的大小，开始接收 */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    tick = rt_tick_get();</span><br><span class="line">    <span class="comment">/* 在100ms内读完指定大小的包 */</span></span><br><span class="line">    <span class="keyword">while</span> (rt_tick_get() &lt;= (tick + rt_tick_from_millisecond(<span class="number">100</span>)) &amp;&amp; i &lt; (data_sz - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 使用长度限制和时间限制来读取一块数据，多次调用底层读取函数好像是重复读取？ */</span></span><br><span class="line">        i += _rym_read_data(ctx, data_sz - <span class="number">1</span>);</span><br><span class="line">        rt_thread_mdelay(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 超时导致长度较短，或者接收的数据包过长 */</span></span><br><span class="line">    <span class="keyword">if</span> (i != (data_sz - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_DSZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity check，第一个包index为0，反码为ff，错误的数据块序号 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;buf[<span class="number">1</span>] != <span class="number">0</span> || ctx-&gt;buf[<span class="number">2</span>] != <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_SEQ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取出接收到的CRC校验码 */</span></span><br><span class="line">    recv_crc = (<span class="keyword">rt_uint16_t</span>)(*(ctx-&gt;buf + data_sz - <span class="number">2</span>) &lt;&lt; <span class="number">8</span>) | *(ctx-&gt;buf + data_sz - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 计算接收到的buff内容的CRC，跳过关键字1Byte和数据块序号2Bytes，同时不包括最后2Bytes CRC */</span></span><br><span class="line">    cal_crc = CRC16(ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* CRC校验错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (recv_crc != cal_crc)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CRC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析数据块中的内容，获得传输文件的文件名等信息，On_Begin为应用层调用核心层时传入的函数，用于解析第一个数据块 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>) != RYM_CODE_ACK)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CAN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_do_send_handshake</p>
</blockquote>
<p>该函数用于Ymodem协议<strong>发送</strong>时的握手，该发送端等待接受端准备完毕，该发送端接收到接受端发送的代码C后，发送第一个数据块，接受端接收成功返回ACK和代码C后代表连接建立，执行发送任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_send_handshake(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">int</span> tm_sec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> rym_code code;</span><br><span class="line">    <span class="keyword">rt_size_t</span> i;</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> getc_ack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入连接等待建立状态 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_ESTABLISHING;</span><br><span class="line">    <span class="comment">/* 握手时是第一个数据块，第一个数据块为小包128 Bytes */</span></span><br><span class="line">    data_sz = _RYM_SOH_PKG_SZ;</span><br><span class="line">    <span class="comment">/* 不断读取通讯设备，检测接受端是否发送代码C，超时为接收到代码C则代表握手失败 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tm_sec; i++) &#123;</span><br><span class="line">        code = _rym_read_code(ctx, RYM_CHD_INTV_TICK);</span><br><span class="line">        <span class="keyword">if</span> (code == RYM_CODE_C) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == tm_sec) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_TMO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用应用层传入的on_begin回调函数，该函数需要填充发送的第一个数据块所需的数据，仅填充数据部分 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>) != RYM_CODE_SOH)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">	<span class="comment">/* 将数据块关键字和索引（第一个数据块索引为0）封包发送 */</span></span><br><span class="line">    code = RYM_CODE_SOH;</span><br><span class="line">    _rym_send_packet(ctx, code, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跳转函数在上层已经设置过了？不知道为什么再设置一遍，可能防止用户在on_begin中做了修改？？ */</span></span><br><span class="line">    rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind);</span><br><span class="line">    <span class="comment">/* 该getchar函数与readcode的不同之处是没有timeout，若下位机不给ACK，该函数将永远等待 */</span></span><br><span class="line">    getc_ack = _rym_getchar(ctx);</span><br><span class="line">	<span class="comment">/* 若返回的不是ACK，退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (getc_ack != RYM_CODE_ACK) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 接受端返回ACK后需要再次发送代码C，代表接收成功，并准备好接收下一次传输（至少有一次真正的文件内容的传输） */</span></span><br><span class="line">    getc_ack = _rym_getchar(ctx);</span><br><span class="line">	<span class="comment">/* 若返回的不是C，退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (getc_ack != RYM_CODE_C) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 握手成功，通讯建立 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_ESTABLISHED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="trans">trans</span></h3><blockquote>
<p>do_trans</p>
</blockquote>
<p>该函数用于接受端接收数据块，是<code>rym_recv_on_device</code>函数的下层，负责状态控制，执行接收任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_trans(struct rym_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 握手成功后，需要向发送端发送ACK和代码C，表示接收成功，申请下一次接收 */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_ACK);</span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_C);</span><br><span class="line">    <span class="comment">/* 连接状态建立 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_ESTABLISHED;</span><br><span class="line">	<span class="comment">/* 进入接收循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">rt_err_t</span> err;</span><br><span class="line">        <span class="keyword">enum</span> rym_code code;</span><br><span class="line">        <span class="keyword">rt_size_t</span> data_sz, i;</span><br><span class="line">		<span class="comment">/* 读取第一个关键字字节，获得即将要传输的字节大小，若关键字为EOT，代表传输结束 */</span></span><br><span class="line">        code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK);</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> RYM_CODE_SOH:</span><br><span class="line">            data_sz = <span class="number">128</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RYM_CODE_STX:</span><br><span class="line">            data_sz = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RYM_CODE_EOT:</span><br><span class="line">            <span class="keyword">return</span> RT_EOK;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 传输data_sz指定大小的数据，存放到ctx的buf中，由应用层函数on_data进行数据的使用</span></span><br><span class="line"><span class="comment">         * 返回code用于控制继续传输或者中止传输</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        err = _rym_trans_data(ctx, data_sz, &amp;code);</span><br><span class="line">        <span class="keyword">if</span> (err != RT_EOK)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">switch</span> (code)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* Ymodem协议规定中止传输指令需要多次发送 */</span></span><br><span class="line">        <span class="keyword">case</span> RYM_CODE_CAN:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RYM_END_SESSION_SEND_CAN_NUM; i++) &#123;</span><br><span class="line">                _rym_putchar(ctx, RYM_CODE_CAN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -RYM_ERR_CAN;</span><br><span class="line">        <span class="comment">/* 发送应答，等待接收下一次传输 */</span></span><br><span class="line">        <span class="keyword">case</span> RYM_CODE_ACK:</span><br><span class="line">            _rym_putchar(ctx, RYM_CODE_ACK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>do_send_trans</p>
</blockquote>
<p>该函数用于发送端发送数据块，是<code>rym_recv_on_device</code>函数的下层，负责数据填充和发送，执行发送任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_send_trans(struct rym_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_TRANSMITTING;</span><br><span class="line">    <span class="keyword">enum</span> rym_code code;</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz;</span><br><span class="line">    <span class="comment">/* 数据块为第二个包，索引为1 */</span></span><br><span class="line">    <span class="keyword">rt_uint32_t</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> getc_ack;</span><br><span class="line">	<span class="comment">/* RTT可能只实现了发送小包？ */</span></span><br><span class="line">    data_sz = _RYM_SOH_PKG_SZ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 由应用层负责填充数据 */</span></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;on_data &amp;&amp; ctx-&gt;on_data(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>) != RYM_CODE_SOH)</span><br><span class="line">            <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">		</span><br><span class="line">        code = RYM_CODE_SOH;</span><br><span class="line">        _rym_send_packet(ctx, code, index);</span><br><span class="line">        index++;</span><br><span class="line">        </span><br><span class="line">        rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind);</span><br><span class="line"></span><br><span class="line">        getc_ack = _rym_getchar(ctx);</span><br><span class="line">        <span class="keyword">if</span> (getc_ack != RYM_CODE_ACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;stage == RYM_STAGE_FINISHING)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="fin">fin</span></h3><blockquote>
<p>do_fin</p>
</blockquote>
<p>fin我觉得是finish。该函数用于实现发送端发送EOT信号之后的部分协议，执行接收任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_fin(struct rym_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> rym_code code;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> recv_crc;</span><br><span class="line">    <span class="keyword">rt_size_t</span> i;</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 状态更新为完成一次传输，但可能没有结束，因为Ymodem协议支持连续传输 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_FINISHING;</span><br><span class="line">	<span class="comment">/* 如果定义了on_end回调函数，执行该函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;on_end)</span><br><span class="line">        ctx-&gt;on_end(ctx, ctx-&gt;buf + <span class="number">3</span>, <span class="number">128</span>);</span><br><span class="line">	<span class="comment">/* 在接收到第一次EOT的时候，接受端需要先返回一次NACK */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_NAK);</span><br><span class="line">	<span class="comment">/* 然后进行监听，等待EOT的二次确认 */</span></span><br><span class="line">    code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK);</span><br><span class="line">	<span class="comment">/* 如果未收到二次确认，代表指令接收存在错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (code != RYM_CODE_EOT)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">	<span class="comment">/* 接收到二次确认，返回ACK和代码C */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_ACK);</span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_C);</span><br><span class="line">    <span class="comment">/* 准备接收最后一个数据块 */</span></span><br><span class="line">    code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK);</span><br><span class="line">    <span class="keyword">if</span> (code == RYM_CODE_SOH) &#123;</span><br><span class="line">        data_sz = _RYM_SOH_PKG_SZ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code == RYM_CODE_STX) &#123;</span><br><span class="line">        data_sz = _RYM_STX_PKG_SZ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">	<span class="comment">/* 由于已经读掉一个关键字，因此size-1 */</span></span><br><span class="line">    i = _rym_read_data(ctx, _RYM_SOH_PKG_SZ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != (_RYM_SOH_PKG_SZ - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_DSZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最后一个数据块的索引必须为0，反码即为ff */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;buf[<span class="number">1</span>] != <span class="number">0</span> || ctx-&gt;buf[<span class="number">2</span>] != <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_SEQ;</span><br><span class="line">	<span class="comment">/* CRC校验 */</span></span><br><span class="line">    recv_crc = (<span class="keyword">rt_uint16_t</span>)(*(ctx-&gt;buf + _RYM_SOH_PKG_SZ - <span class="number">2</span>) &lt;&lt; <span class="number">8</span>) | *(ctx-&gt;buf + _RYM_SOH_PKG_SZ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (recv_crc != CRC16(ctx-&gt;buf + <span class="number">3</span>, _RYM_SOH_PKG_SZ - <span class="number">5</span>))</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CRC;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果该数据包的数据部分不为零，代表EOT之后还要准备下一次传输</span></span><br><span class="line"><span class="comment">     * 该数据包的内容为下一次传输的第一个包，包含文件名和size等信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;buf[<span class="number">3</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>) != RYM_CODE_ACK)</span><br><span class="line">            <span class="keyword">return</span> -RYM_ERR_CAN;</span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 最后一个数据包的数据部分为0，代表传输结束，没有二次传输 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_FINISHED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回整次传输的最后一个ACK */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_ACK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>do_send_fin</p>
</blockquote>
<p>该函数用于实现发送端发送EOT信号之后由发送端完成的部分的协议，执行发送任务时执行该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_do_send_fin(struct rym_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> rym_code code;</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> getc_ack;</span><br><span class="line"></span><br><span class="line">    data_sz = _RYM_SOH_PKG_SZ;</span><br><span class="line">    rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind);</span><br><span class="line">	<span class="comment">/* 发送EOT */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_EOT);</span><br><span class="line">    getc_ack = _rym_getchar(ctx);</span><br><span class="line">	<span class="comment">/* 如果没有接收到ACK */</span></span><br><span class="line">    <span class="keyword">if</span> (getc_ack != RYM_CODE_NAK) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 如果接收到ACK，再次发送EOT，进行二次确认 */</span></span><br><span class="line">    _rym_putchar(ctx, RYM_CODE_EOT);</span><br><span class="line">    getc_ack = _rym_getchar(ctx);</span><br><span class="line">    <span class="keyword">if</span> (getc_ack != RYM_CODE_ACK) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 二次确认成功，且读到代码C，可以发送最后一个数据包 */</span></span><br><span class="line">    getc_ack = _rym_getchar(ctx);</span><br><span class="line">    <span class="keyword">if</span> (getc_ack != RYM_CODE_C) &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_ACK;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 应用层填充最后一个数据包 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;on_end &amp;&amp; ctx-&gt;on_end(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz - <span class="number">5</span>) != RYM_CODE_SOH)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CODE;</span><br><span class="line">    <span class="comment">/* 分包发送最后一个数据块 */</span></span><br><span class="line">    code = RYM_CODE_SOH;</span><br><span class="line">    _rym_send_packet(ctx, code, index);</span><br><span class="line">	<span class="comment">/* 状态设置为传输结束 */</span></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_FINISHED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="基础函数">基础函数</span></h3><p>基础函数是整个核心层最底层的接口，与操作系统交换信息；</p>
<blockquote>
<p>_rym_read_code</p>
</blockquote>
<p>该函数用于读取帧头关键字；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> rym_code _rym_read_code(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">rt_tick_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 如果缓存中已有数据，直接取出一个就是关键字 */</span></span><br><span class="line">    <span class="keyword">if</span> (rt_device_read(ctx-&gt;dev, <span class="number">0</span>, ctx-&gt;buf, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">enum</span> rym_code)(*ctx-&gt;buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果缓存中没有 */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">rt_size_t</span> rsz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待信号量到达，接收一个关键字 */</span></span><br><span class="line">        <span class="keyword">if</span> (rt_sem_take(&amp;ctx-&gt;sem, timeout) != RT_EOK)</span><br><span class="line">            <span class="keyword">return</span> RYM_CODE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读取一个关键字 */</span></span><br><span class="line">        rsz = rt_device_read(ctx-&gt;dev, <span class="number">0</span>, ctx-&gt;buf, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (rsz == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">enum</span> rym_code)(*ctx-&gt;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_read_data</p>
</blockquote>
<p>该函数用于从通讯端口设备中读取长度为len的数据块，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_size_t</span> _rym_read_data(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">rt_size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 第一个字节是关键字，因此数据存储需要偏移一个字节 */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *buf = ctx-&gt;buf + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rt_size_t</span> readlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向系统拿取一定长度的数据 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        readlen += rt_device_read(ctx-&gt;dev, <span class="number">0</span>, buf + readlen, len - readlen);</span><br><span class="line">        <span class="keyword">if</span> (readlen &gt;= len)</span><br><span class="line">            <span class="keyword">return</span> readlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 信号量的等待设定超时机制 */</span></span><br><span class="line">    <span class="keyword">while</span> (rt_sem_take(&amp;ctx-&gt;sem, RYM_WAIT_CHR_TICK) == RT_EOK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_send_packet</p>
</blockquote>
<p>该函数用于发送小包（128Bytes），仅作为发送端时使用，RTT可能仅实现了小包发送的发送端？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_send_packet(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">enum</span> rym_code code,</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> send_crc;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> index_inv = ~index;</span><br><span class="line">    <span class="keyword">rt_size_t</span> writelen = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 计算CRC，填充相关数据到数据块 */</span></span><br><span class="line">    send_crc = CRC16(ctx-&gt;buf + <span class="number">3</span>, _RYM_SOH_PKG_SZ - <span class="number">5</span>);</span><br><span class="line">    ctx-&gt;buf[<span class="number">0</span>] = code;</span><br><span class="line">    ctx-&gt;buf[<span class="number">1</span>] = index;</span><br><span class="line">    ctx-&gt;buf[<span class="number">2</span>] = index_inv;</span><br><span class="line">    ctx-&gt;buf[<span class="number">131</span>] = (<span class="keyword">rt_uint8_t</span>)(send_crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    ctx-&gt;buf[<span class="number">132</span>] = (<span class="keyword">rt_uint8_t</span>)send_crc &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">/* 向操作系统内的设备发送数据块 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        writelen += rt_device_write(ctx-&gt;dev, <span class="number">0</span>, ctx-&gt;buf + writelen,</span><br><span class="line">                                    _RYM_SOH_PKG_SZ - writelen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (writelen &lt; _RYM_SOH_PKG_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>_rym_trans_data</p>
</blockquote>
<p>该函数用于从操作系统接收数据块，为核心层所有接收数据块操作的最底层；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> _rym_trans_data(</span><br><span class="line">    struct rym_ctx *ctx,</span><br><span class="line">    <span class="keyword">rt_size_t</span> data_sz,</span><br><span class="line">    <span class="keyword">enum</span> rym_code *code)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在调用该函数之前，一定且必须已经读取过关键字，获得接下来需要传输的数据块的大小</span></span><br><span class="line"><span class="comment">     * 因此tran_size为2Bytes Index和~Index，data_size和2Bytes CRC Code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rt_size_t</span> tsz = <span class="number">2</span> + data_sz + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">rt_uint16_t</span> recv_crc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* seq + data + crc */</span></span><br><span class="line">    <span class="keyword">rt_size_t</span> i = _rym_read_data(ctx, tsz);</span><br><span class="line">    <span class="keyword">if</span> (i != tsz)</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_DSZ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ctx-&gt;buf[<span class="number">1</span>] + ctx-&gt;buf[<span class="number">2</span>]) != <span class="number">0xFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_SEQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* As we are sending C continuously, there is a chance that the</span></span><br><span class="line"><span class="comment">     * sender(remote) receive an C after sending the first handshake package.</span></span><br><span class="line"><span class="comment">     * So the sender will interpret it as NAK and re-send the package. So we</span></span><br><span class="line"><span class="comment">     * just ignore it and proceed. */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;stage == RYM_STAGE_ESTABLISHED &amp;&amp; ctx-&gt;buf[<span class="number">1</span>] == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *code = RYM_CODE_NONE;</span><br><span class="line">        <span class="keyword">return</span> RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;stage = RYM_STAGE_TRANSMITTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity check */</span></span><br><span class="line">    recv_crc = (<span class="keyword">rt_uint16_t</span>)(*(ctx-&gt;buf + tsz - <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | *(ctx-&gt;buf + tsz);</span><br><span class="line">    <span class="keyword">if</span> (recv_crc != CRC16(ctx-&gt;buf + <span class="number">3</span>, data_sz))</span><br><span class="line">        <span class="keyword">return</span> -RYM_ERR_CRC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* congratulations, check passed. */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;on_data)</span><br><span class="line">        *code = ctx-&gt;on_data(ctx, ctx-&gt;buf + <span class="number">3</span>, data_sz);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *code = RYM_CODE_ACK;</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="应用层ota应用">应用层（OTA应用）</span></h2><p>应用层实现于”ota_downloader/ymodem_ota.c”，是通过调用Ymodem核心层api进行OTA升级的应用实现。</p>
<p>Ymodem_ota的应用层包括三个部分：</p>
<ul>
<li><a href="#OTA">OTA</a>开启一次升级，内部解析传入的，升级所需的参数，输出部分提示信息，调用核心层<code>rym_recv_on_device()</code>接口进行数据接收；</li>
<li>on_begin，解析传入的第一个数据块，获得升级所需的Flash空间大小，检查Flash设备、空间是否满足升级需求，然后擦除；</li>
<li>on_data，取出底层获得数据块，写入Flash指定位置；</li>
</ul>
<h3><span id="on_begin">on_begin</span></h3><p>该函数解析第一个数据块，获得文件信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> rym_code <span class="title">ymodem_on_begin</span><span class="params">(struct rym_ctx *ctx, <span class="keyword">rt_uint8_t</span> *buf, <span class="keyword">rt_size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file_name, *file_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得文件名称，文件名称以0结尾 */</span></span><br><span class="line">    file_name = (<span class="keyword">char</span> *)&amp;buf[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* 偏移文件名称长度+结尾0，首地址为文件大小信息 */</span></span><br><span class="line">    file_size = (<span class="keyword">char</span> *)&amp;buf[rt_strlen(file_name) + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* 字符串转换获得文件大小 */</span></span><br><span class="line">    update_file_total_size = atol(file_size);</span><br><span class="line">    rt_kprintf(<span class="string">"Ymodem file_size:%d\n"</span>, update_file_total_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 完成更新的文件部分尺寸 */</span></span><br><span class="line">    update_file_cur_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get download partition information and erase download partition data */</span></span><br><span class="line">    <span class="comment">/* 未找到下载分区 */</span></span><br><span class="line">    <span class="keyword">if</span> ((dl_part = fal_partition_find(recv_partition)) == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_E(<span class="string">"Firmware download failed! Partition (%s) find error!"</span>, recv_partition);</span><br><span class="line">        <span class="keyword">return</span> RYM_CODE_CAN;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 文件大于下载分区 */</span></span><br><span class="line">    <span class="keyword">if</span> (update_file_total_size &gt; dl_part-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_E(<span class="string">"Firmware is too large! File size (%d), '%s' partition size (%d)"</span>, update_file_total_size, recv_partition, dl_part-&gt;len);</span><br><span class="line">        <span class="keyword">return</span> RYM_CODE_CAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_I(<span class="string">"Start erase. Size (%d)"</span>, update_file_total_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* erase DL section */</span></span><br><span class="line">    <span class="keyword">if</span> (fal_partition_erase(dl_part, <span class="number">0</span>, update_file_total_size) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_E(<span class="string">"Firmware download failed! Partition (%s) erase error!"</span>, dl_part-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> RYM_CODE_CAN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 擦除所需的Flash空间成功，下一个数据块接收后可以写入 */</span></span><br><span class="line">    <span class="keyword">return</span> RYM_CODE_ACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="on_data">on_data</span></h3><p>该函数实现数据块写入Flash；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> rym_code <span class="title">ymodem_on_data</span><span class="params">(struct rym_ctx *ctx, <span class="keyword">rt_uint8_t</span> *buf, <span class="keyword">rt_size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 将解出的数据包写入到Flash  */</span></span><br><span class="line">    <span class="keyword">if</span> (fal_partition_write(dl_part, update_file_cur_size, buf, len) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_E(<span class="string">"Firmware download failed! Partition (%s) write data error!"</span>, dl_part-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> RYM_CODE_CAN;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 每个数据块写入flash后，记录写入的size，作为下次写入的地址 */</span></span><br><span class="line">    update_file_cur_size += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RYM_CODE_ACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="ota">ota</span></h3><blockquote>
<p>Firmware Over-the-Air Technology</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ymodem_ota</span><span class="params">(<span class="keyword">uint8_t</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rym_ctx</span> <span class="title">rctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有参数输入，使用默认配置（下载的分区名为“download”） */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        recv_partition = DEFAULT_DOWNLOAD_PART;</span><br><span class="line">        rt_kprintf(<span class="string">"Default save firmware on download partition.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使用-p选项加分区名参数自定义下载分区 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">operator</span> = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="keyword">operator</span>, <span class="string">"-p"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">"Usage: ymodem_ota -p &lt;partiton name&gt;.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* change default partition to save firmware */</span></span><br><span class="line">                recv_partition = argv[<span class="number">2</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rt_kprintf(<span class="string">"Usage: ymodem_ota -p &lt;partiton name&gt;.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"Warning: Ymodem has started! This operator will not recovery.\n"</span>);</span><br><span class="line">    rt_kprintf(<span class="string">"Please select the ota firmware file and use Ymodem to send.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调用核心层接收数据接口</span></span><br><span class="line"><span class="comment">     * rctx控制器包含状态变量，回调函数，buf，信号量，通讯端口设备 </span></span><br><span class="line"><span class="comment">     * rt_console_get_device()获得控制台使用的通讯端口设备，也可使用其他端口设备传输</span></span><br><span class="line"><span class="comment">     * RT_DEVICE_OFLAG_RDWR：以读写模式打开设备，RT_DEVICE_FLAG_INT_RX：以中断模式接收</span></span><br><span class="line"><span class="comment">     * ymodem_on_begin：解析第一个数据块</span></span><br><span class="line"><span class="comment">     * ymodem_on_data：数据块写入</span></span><br><span class="line"><span class="comment">     * NULL：未定义on_end函数</span></span><br><span class="line"><span class="comment">     * RT_TICK_PER_SECOND：timeout为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!rym_recv_on_device(&amp;rctx, rt_console_get_device(), RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX,</span><br><span class="line">                            ymodem_on_begin, ymodem_on_data, <span class="literal">NULL</span>, RT_TICK_PER_SECOND))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 接收和存储数据成功 */</span></span><br><span class="line">        rt_kprintf(<span class="string">"Download firmware to flash success.\n"</span>);</span><br><span class="line">        rt_kprintf(<span class="string">"System now will restart...\r\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* wait some time for terminal response finish */</span></span><br><span class="line">        rt_thread_delay(rt_tick_from_millisecond(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reset the device, Start new firmware */</span></span><br><span class="line">        <span class="comment">/* 系统将会重启，Download分区中的内容将在启动后由Bootloader搬运到App分区，然后从App分区执行 */</span></span><br><span class="line">        <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rt_hw_cpu_reset</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        rt_hw_cpu_reset();</span><br><span class="line">        <span class="comment">/* wait some time for terminal response finish */</span></span><br><span class="line">        rt_thread_delay(rt_tick_from_millisecond(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* wait some time for terminal response finish */</span></span><br><span class="line">        <span class="comment">/* 接收或存储数据失败 */</span></span><br><span class="line">        rt_thread_delay(RT_TICK_PER_SECOND);</span><br><span class="line">        rt_kprintf(<span class="string">"Update firmware fail.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Ymodem/">Ymodem</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%8D%8F%E8%AE%AE/">协议</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/">文件传输</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/img_donate/donate_alipay.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/img_donate/donate_wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">嵌入式开发疑难杂症</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/14/Ubuntu%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"><span class="level-item">Ubuntu基础配置记录</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="zZHongyu"></figure><p class="title is-size-4 is-block line-height-inherit">zZHongyu</p><p class="is-size-6 is-block">Elec-Info Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China,Earth</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/gerald0057" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/gerald0057"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Tsinghua Open</span></span><span class="level-right"><span class="level-item tag">mirrors.tuna.tsinghua.edu.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://flatuicolors.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Flat UI</span></span><span class="level-right"><span class="level-item tag">flatuicolors.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://leetcode-cn.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.rt-thread.org/document/site/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">RTT Doc</span></span><span class="level-right"><span class="level-item tag">www.rt-thread.org</span></span></a></li></ul></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-08T15:21:32.000Z">2020-08-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/">嵌入式开发疑难杂症</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-15T12:34:02.000Z">2020-07-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/15/Ymodem-RTT/">Ymodem RTT</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-14T15:45:08.000Z">2020-07-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/14/Ubuntu%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">Ubuntu基础配置记录</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-14T15:42:54.000Z">2020-07-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/14/Windows-Terminal-%E9%85%8D%E7%BD%AE-Powerline/">Windows Terminal 配置 Powerline</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Powerline/"><span class="tag">Powerline</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-Terminal/"><span class="tag">Windows Terminal</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ymodem/"><span class="tag">Ymodem</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8F%E8%AE%AE/"><span class="tag">协议</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"><span class="tag">文件传输</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="tag">源码阅读</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"><span class="tag">疑难杂症</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"><span class="tag">系统配置</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BE%8E%E5%8C%96/"><span class="tag">美化</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%B0%E5%BD%95/"><span class="tag">记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%85%8D%E7%BD%AE/"><span class="tag">配置</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="zZHongyu的博客" height="28"></a><p class="size-small"><span>&copy; 2020 朱洪煜</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/gerald0057"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>