{"pages":[],"posts":[{"title":"Ubuntu基础配置记录","text":"换源 常用apt指令 Git配置代理 设置代理 取消代理 查看代理 换源阿里云： 1234$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.old # for backup$ sudo sed -i 's/security.ubuntu/mirrors.aliyun/g' /etc/apt/sources.list$ sudo sed -i 's/archive.ubuntu/mirrors.aliyun/g' /etc/apt/sources.list$ sudo apt update 常用apt指令12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 Git配置代理设置代理123456# http代理git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080# socks5代理 (ssr)git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 取消代理12git config --global --unset http.proxygit config --global --unset https.proxy 查看代理1git config --global http.proxy","link":"/2020/07/14/Ubuntu%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"Windows Terminal 配置 Powerline","text":"Powerline 提供自定义的命令提示符体验，提供 Git 状态颜色编码和提示符 本教程配置了PowerShell和WSL在Windows Terminal中的Powerline，除了第一点安装Powerline字体为必需步骤，剩余两点不影响，可选择配置 在windows中安装Powerline字体 在PowerShell中设置Powerline字体 在WSL-Ubuntu中安装Zsh和Oh-My-Zsh 在windows中安装Powerline字体下载微软开源Cascadia Code，这里下载了CascadiaCode-2007.01.zip，解压安装PL（Powerline）字体，Cascadia Code PL 或 Cascadia Mono PL包含Powerline字体，其他不包含。 在PowerShell中设置Powerline字体 确保Windows中安装有Git 打开Windows Terminal的PowerShell页，安装Posh-Git和Oh-My-Posh 12Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser 出现提示选择[Y]“是” 然后使用指令打开PowerShell 配置文件，该脚本在每次启动 PowerShell 时运行 1notepad $PROFILE 将以下内容追加到文件内 123Import-Module posh-gitImport-Module oh-my-poshSet-Theme Paradox 每个新实例启动时都会导入 Posh-Git 和 Oh-My-Posh，然后从 Oh-My-Posh 设置 Paradox 主题 如果没有使用过配置文件，在打开配置文件时会提示没有该文件，直接新建即可 修改配置文件后，重启PowerShell，若出现在此系统上禁止运行脚本的提示，需要以管理员身份启动PowerShell，执行指令set-executionpolicy remotesigned即可允许运行脚本 打开Windows Terminal的配置文件settings.json，添加fontFace字段，举例如下： 1234567{ \"guid\": \"xxx\", \"name\": \"Windows PowerShell\", \"commandline\": \"powershell.exe\", \"hidden\": false, \"fontFace\": \"Cascadia Mono PL\"}, 添加字段注意不要漏了逗号，安装了Mono字体则添加”Cascadia Mono PL”，Code字体则添加”Cascadia Code PL” 重启PowerShell 在WSL-Ubuntu中安装Zsh和Oh-My-Zsh12sudo apt install zshsudo chsh -s `which zsh` #设置默认shell为zsh 1sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 如果（一般）下不下来，直接Github，选择一个合适的路径clone仓库 1git clone https://github.com/ohmyzsh/ohmyzsh.git --depth=1 进入仓库 123456sudo cp ./templates/zshrc.zsh-template ~/.zshrcsudo vim ~/.zshrc# 修改ZSH路径指向clone下来的仓库，仓库不能删除export ZSH=$HOME/Git_Repos/ohmyzsh# 这是我的路径source ~/.zshrc 重启终端 在WSL-Ubuntu中设置Powerline字体 这里使用Go 安装Go 1sudo apt install golang-go 解决Go资源被墙，打开shell的配置文件，这里打开~/.profile，追加： 12export GO111MODULE=onexport GOPROXY=https://goproxy.io 更新配置： 1source ~/.profile 下载powerline-go 1go get -u github.com/justjanne/powerline-go 自定义主题，这里定义为agnoster，可查看仓库themes下内容，配置时去除后缀 1234sudo vim ~/.zshrc# 修改主题配置ZSH_THEME=\"agnoster\"source ~/.zshrc 若出现安全性报错，进入.zshrc，添加 ZSH_DISABLE_COMPFIX=”true” 字段 自定义Ubuntu提示符 1sudo vim ~/.zshrc 添加如下内容，如果Go的安装更改了默认的路径，应当修改下面的GOPATH为正确的路径 1234567891011121314151617GOPATH=$HOME/gofunction powerline_precmd() { PS1=\"$($GOPATH/bin/powerline-go -error $? -shell zsh)\"}function install_powerline_precmd() { for s in \"${precmd_functions[@]}\"; do if [ \"$s\" = \"powerline_precmd\" ]; then return fi done precmd_functions+=(powerline_precmd)}if [ \"$TERM\" != \"linux\" ]; then install_powerline_precmdfi 1source ~/.zshrc","link":"/2020/07/14/Windows-Terminal-%E9%85%8D%E7%BD%AE-Powerline/"},{"title":"嵌入式开发疑难杂症","text":"嵌入式开发疑难杂症（第一篇）这两天在调试加密芯片ATSHA204A的时候，遇到非常奇怪的问题，将Atmel提供的库添加进来，再将同事打包的，包含秘钥信息的静态验证库也添加进来，发现无法启动:confused:，然而在观摩了一边同事添加该库的流程，发现过程一模一样，结果我就跑不起来。。。 介绍由于出事故的环境比较复杂，需要好好介绍一下： 本工程是在RT-Thread的基础上建立的 添加了BootLoader便于OTA升级 事故现场异常惨烈，没有任何debug信息输出，开机即死亡 添加了lib文件，不同的工程，不同的板子，不同的引脚定义，大概只有主频相同 面对这样的事故现场，我有点难受： 系统的启动流程由RTT管理，有一套自己的内核启动流程，包含添加的外设、驱动、组件的启动，如果添加的初始化部分有一些我目前不了解的坑，那么这有可能是事故的诱因之一； BootLoader在完成版本号、固件完整性检查后会发生地址跳转，如果这里除了什么差错，造成的现象与当前的现象非常相似，即只有BootLoader输出，App段没有任何输出； 由于第一次使用自建的lib文件来调用接口，不清楚也不了解在生成、使用lib文件的过程中，编译的配置是否有问题，是否有依赖不清的问题，导致移植出了事故； 细细一想，好像所有可能的诱因都是有极大的可能导致这场事故的发生，我一时分不清手上拿的是电烙铁还是手术刀。 抽丝剥茧 去掉BootLoader，开机进入RTT 失败 去掉RTT，使用新建的、正常启动的工程，添加加密验证库后启动 失败 去掉RTT，使用生成lib所用的原版MCU建立新的、正常启动的工程，添加加密验证库后启动 失败 在经历三大战役后，我的收获就是，为RTT正名了，不是RTT的锅，但是矛头好像都指向了静态库，所有的工程，在没有添加静态库的时候都正常，一旦添加了就立刻暴毙，面对具有重大犯罪嫌疑但没有充足证据的静态库，我选择把它抓过来先拘它24小时。 在暴打（问询）了24小时后，这位静态库先生仍然没有招供，但我却从静态库先生的眼神中读出了它的刚正不阿和，，它的银行卡密码，还好密码比较长，我实在是记不住:sunglasses: 浮出水面将重点放在验证的过程中，我发现在调试的时候，串口老是工作不正常，调试后发现串口的最后一次执行返回的结果居然是BUSY，故意旷工，反正刚才那个嫌疑人也抓不到，先把这个抓起来问询。打了一顿后发现返回的是BUSY，但是结构体中代表状态的标志位却不是BUSY，HAL库中对于返回的设定是只要状态不是READY，就返回BUSY，但是实际的标志位却是一个没有定义的数值类型，证据显示该处BUSY应该是0x24、0x21或者0x22和0x23，但是口供显示值是0x27，要么是嫌犯在作假口供，罪加一等，要么，是有隐藏地更深的Boss暗中操纵着这一切。 12345678910111213141516HAL_UART_STATE_RESET = 0x00U, /*!&lt; Peripheral is not yet Initialized Value is allowed for gState and RxState */HAL_UART_STATE_READY = 0x20U, /*!&lt; Peripheral Initialized and ready for use Value is allowed for gState and RxState */HAL_UART_STATE_BUSY = 0x24U, /*!&lt; an internal process is ongoing Value is allowed for gState only */HAL_UART_STATE_BUSY_TX = 0x21U, /*!&lt; Data Transmission process is ongoing Value is allowed for gState only */HAL_UART_STATE_BUSY_RX = 0x22U, /*!&lt; Data Reception process is ongoing Value is allowed for RxState only */HAL_UART_STATE_BUSY_TX_RX = 0x23U, /*!&lt; Data Transmission and Reception process is ongoing Not to be used for neither gState nor RxState. Value is result of combination (Or) between gState and RxState values */HAL_UART_STATE_TIMEOUT = 0xA0U, /*!&lt; Timeout state Value is allowed for gState only */HAL_UART_STATE_ERROR = 0xE0U /*!&lt; Error 由于串口有时能用，有时却不能用，那么先监控起来，看看是否有幕后黑手来破坏证据，在经历了长达1分钟的监视后，发现黑手： 执行了，，数组？这好像是const，一开始就有的常量，存在flash？为啥会把huart指向的空间写穿？ 在摸排了社会关系之后，发现该新晋嫌疑人，80岁大爷上车居然刷了个学生卡，flash中常量地址应该起码在0x08000000往后的code段，结果这家伙甚至跑到了RAM0x20000000的前面，0x1fffffec的地址非常危险，从0x20000000开始就是开机后一些申请的变量存储的地方，估计就是这个数组把变量写成别的东西然后系统跑飞了，一看uart handle的结构体 从0x2000001C开始，就是uart handle的数据，本应该是保存串口相关的数据，但此时全被写入了嫌疑人k[]数组的内容，人赃俱获 那个导致串口BUSY的证据也在此处被篡改，周围的值也呼应上了，证据链充足，可以批捕了，等待它的将是人民的审判！ 人民的审判证据充足，但动机不明，为什么一个const会导致如此惨案，为什么const修饰的数组没有存放在Flash，其实这个问题遇见过很多次了，很多时候，在函数内部，如果我们申请了一个较大的数组，编译器会报错，放到外面（全局）就可以通过编译，但这次，可能占用空间没有到报错的级别，编译器没有报错，嫌疑人借助这个漏洞实施了违法的行为，视公序良俗于不顾，在系统重要内存处搞破坏，恶意干扰司法机关调查案情，予以代码永久注释，剥夺执行权力终身的处罚。 案情通告1234void func_1(void) { const u8 arr[] = {x, x, x} return;} 1234const u8 arr[] = {x, x, x}void func_2(void) { return;} 对于func_1的写法，arr在MCU中仍处于RAM段，func_2的写法才是将其放入Code段，在编译、编程后存放在Flash中，不占用RAM空间，只是到现在为止还有一点是我搞不清楚的，就是就算该数组属于RAM段，为什么MCU会给它分配一块完全无法容纳下它的空间，并将首地址设定为0x1fffffec，而且就算我将const修饰符去掉也仍然会造成内存写穿的现象，对于这一点，我暂时还没有办法解释，将问题放在这里。 最后一个疑问，之前对于ATSHA204A的应用也成功过，于是我对比了两次的代码，发现之前使用的是新版的ATCA库，由Microchip维护，而现在使用的是市面上已经绝迹的老版本的ATSHA204A的支持库，由被Microchip收购之前的Atmel提供，为什么之前没有出现问题，我看了代码后，大概明白了，世界上的坑，虽然多，但总有 &gt;= 两个人会踩到同一个坑中。 1234void func_3(void) { static const u8 arr[] = {x, x, x} return;}","link":"/2020/08/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"title":"Ymodem RTT","text":"代码阅读：RTT基于Ymodem协议传输文件的实现 核心层 对应用API handshake trans fin 基础函数 应用层（OTA应用） on_begin on_data ota 核心层核心层实现于”Utilities/ymodom.c”，主要完成了基于Ymodem协议的握手和收发业务，向上层应用提供了收发API，需要提供收发的控制器，端口设备，端口开启的参数配置，第一个数据块的处理实现函数on_begin，之后数据块的处理实现函数on_data，可选的收发结束处理函数实现on_end，以及握手的timeout设置； 对应用APIrecv recv_on_device 该函数从通讯端口以Ymodom协议接收数据块，为应用层接收通讯设备返回数据时调用的唯一接口； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667rt_err_t rym_recv_on_device( struct rym_ctx *ctx, rt_device_t dev, rt_uint16_t oflag, rym_callback on_begin, rym_callback on_data, rym_callback on_end, int handshake_timeout){ rt_err_t res; /** * 由于要使用Ymodem协议传输数据，需要独占该设备，因此要修改该通讯设备原始的接收跳转函数 * 所以为了在传输完成后恢复该通讯设备的原始功能，需要先保存原始的接收跳转函数地址 */ rt_err_t (*odev_rx_ind)(rt_device_t dev, rt_size_t size); /* flag定义了以何种方式使用该通讯设备 */ rt_uint16_t odev_flag; int int_lvl; /* 初始化传入的参数，将其与该空间内的全局变量_rym_the_ctx挂钩 */ RT_ASSERT(_rym_the_ctx == 0); _rym_the_ctx = ctx; ctx-&gt;on_begin = on_begin; ctx-&gt;on_data = on_data; ctx-&gt;on_end = on_end; ctx-&gt;dev = dev; /* 初始化通讯信号量用于接收不定长的数据 */ rt_sem_init(&amp;ctx-&gt;sem, \"rymsem\", 0, RT_IPC_FLAG_FIFO); /* 保存该设备原始的跳转函数rx_indicate的地址，以供后续恢复 */ odev_rx_ind = dev-&gt;rx_indicate; /* 修改接收跳转函数，防止设备正在（将要）被访问，屏蔽中断 */ int_lvl = rt_hw_interrupt_disable(); /* 重定向为Ymodem传输时需要的跳转函数 */ rt_device_set_rx_indicate(dev, _rym_rx_ind); /* 保存原始的通讯端口配置flag参数 */ odev_flag = dev-&gt;open_flag; /* 在设备处于流模式，输出的字符是\"\\n\"（0x0A）时，自动在前面输出一个\"\\r\"，该功能有可能会破坏Ymodem协议，因此禁用 */ dev-&gt;open_flag &amp;= ~RT_DEVICE_FLAG_STREAM; /* 通讯设备配置完毕，启用中断 */ rt_hw_interrupt_enable(int_lvl); /* 开启通讯端口设备 */ res = rt_device_open(dev, oflag); if (res != RT_EOK) goto __exit; /* 给定传输控制器和握手时间，接受数据 */ res = _rym_do_recv(ctx, handshake_timeout); /* 数据接收完毕，接收状态和错误状态分别保存在res和ctx内，关闭通讯设备 */ rt_device_close(dev); /* 设备开启失败或者数据接受完毕 */__exit: /* no rx_ind should be called before the callback has been fully detached. */ int_lvl = rt_hw_interrupt_disable(); /* 信号量已失去作用，将其从线程通讯空间内分离 */ rt_sem_detach(&amp;ctx-&gt;sem); /* 恢复原始的设备flag参数 */ dev-&gt;open_flag = odev_flag; /* 恢复原始的接收跳转函数 */ rt_device_set_rx_indicate(dev, odev_rx_ind); rt_hw_interrupt_enable(int_lvl); /* 复位全局指针，防止危险操作 */ _rym_the_ctx = RT_NULL; return res;} _rym_do_recv 12345678910111213141516171819202122232425262728293031323334353637383940static rt_err_t _rym_do_recv( struct rym_ctx *ctx, int handshake_timeout){ rt_err_t err; /* 复位控制器状态 */ ctx-&gt;stage = RYM_STAGE_NONE; /* 至少保证一个大包的空间已被成功申请 */ ctx-&gt;buf = rt_malloc(_RYM_STX_PKG_SZ); if (ctx-&gt;buf == RT_NULL) return -RT_ENOMEM; /* 与发送端握手 */ err = _rym_do_handshake(ctx, handshake_timeout); if (err != RT_EOK) { /* 握手失败，释放动态申请的内存 */ rt_free(ctx-&gt;buf); return err; } /* 握手成功后，进入收发循环 */ while (1) { /* 执行传输任务 */ err = _rym_do_trans(ctx); if (err != RT_EOK) { rt_free(ctx-&gt;buf); return err; } /* 执行传输完成后任务 */ err = _rym_do_fin(ctx); if (err != RT_EOK) { rt_free(ctx-&gt;buf); return err; } /* 循环跳出 */ if (ctx-&gt;stage == RYM_STAGE_FINISHED) break; } /* 释放 */ rt_free(ctx-&gt;buf); return err;} send send_on_device 该函数从通讯端口以Ymodom协议发送数据块，为应用层从通讯设备发送数据时调用的唯一接口； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253rt_err_t rym_send_on_device( struct rym_ctx *ctx, rt_device_t dev, rt_uint16_t oflag, rym_callback on_begin, rym_callback on_data, rym_callback on_end, int handshake_timeout){ rt_err_t res = 0; rt_err_t (*odev_rx_ind)(rt_device_t dev, rt_size_t size); rt_uint16_t odev_flag; int int_lvl; RT_ASSERT(_rym_the_ctx == 0); _rym_the_ctx = ctx; ctx-&gt;on_begin = on_begin; ctx-&gt;on_data = on_data; ctx-&gt;on_end = on_end; ctx-&gt;dev = dev; rt_sem_init(&amp;ctx-&gt;sem, \"rymsem\", 0, RT_IPC_FLAG_FIFO); odev_rx_ind = dev-&gt;rx_indicate; int_lvl = rt_hw_interrupt_disable(); rt_device_set_rx_indicate(dev, _rym_rx_ind); odev_flag = dev-&gt;open_flag; dev-&gt;open_flag &amp;= ~RT_DEVICE_FLAG_STREAM; rt_hw_interrupt_enable(int_lvl); res = rt_device_open(dev, oflag); if (res != RT_EOK) goto __exit; /* 给定传输控制器和握手时间，发送数据 */ res = _rym_do_send(ctx, handshake_timeout); rt_device_close(dev);__exit: int_lvl = rt_hw_interrupt_disable(); rt_sem_detach(&amp;ctx-&gt;sem); dev-&gt;open_flag = odev_flag; rt_device_set_rx_indicate(dev, odev_rx_ind); rt_hw_interrupt_enable(int_lvl); _rym_the_ctx = RT_NULL; return res;} _rym_do_send 123456789101112131415161718192021222324252627282930313233static rt_err_t _rym_do_send( struct rym_ctx *ctx, int handshake_timeout){ rt_err_t err; ctx-&gt;stage = RYM_STAGE_NONE; ctx-&gt;buf = rt_malloc(_RYM_STX_PKG_SZ); if (ctx-&gt;buf == RT_NULL) return -RT_ENOMEM; /* Ymodem协议为接受端驱动型，发送时单次顺序执行 */ err = _rym_do_send_handshake(ctx, handshake_timeout); if (err != RT_EOK) { rt_free(ctx-&gt;buf); return err; } err = _rym_do_send_trans(ctx); if (err != RT_EOK) { rt_free(ctx-&gt;buf); return err; } err = _rym_do_send_fin(ctx); if (err != RT_EOK) { rt_free(ctx-&gt;buf); return err; } rt_free(ctx-&gt;buf); return err;} handshake _rym_do_handshake 该函数用于Ymodem协议接收时的握手，该接收端不断发送代码C，同时等待发送端返回第一个包，接收并检测后交于应用层处理，处理无错误代表握手成功，执行接收任务时执行该函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static rt_err_t _rym_do_handshake( struct rym_ctx *ctx, int tm_sec){ enum rym_code code; rt_size_t i; rt_uint16_t recv_crc, cal_crc; rt_size_t data_sz; rt_tick_t tick; /* 进入连接等待建立状态 */ ctx-&gt;stage = RYM_STAGE_ESTABLISHING; /* 每隔一段时间发送代码C，代表等待建立通讯. */ for (i = 0; i &lt; tm_sec; i++) { /* 发送代码C */ _rym_putchar(ctx, RYM_CODE_C); /* 等待读取，每次等待RYM_CHD_INTV_TICK时间 */ code = _rym_read_code(ctx, RYM_CHD_INTV_TICK); /* 如果关键字为SOH，代表接收小包，设置接收长度为1+2+128+2Bytes */ if (code == RYM_CODE_SOH) { data_sz = _RYM_SOH_PKG_SZ; break; } /* 如果关键字为STX，代表接收大包，设置接收长度为1+2+1024+2Bytes */ else if (code == RYM_CODE_STX) { data_sz = _RYM_STX_PKG_SZ; break; } } /* 经过tm_sec次循环，没有读到正确的关键字后退出for循环，代表传输timeout，返回错误 */ if (i == tm_sec) { return -RYM_ERR_TMO; } /* 读到关键字，得到包的大小，开始接收 */ i = 0; tick = rt_tick_get(); /* 在100ms内读完指定大小的包 */ while (rt_tick_get() &lt;= (tick + rt_tick_from_millisecond(100)) &amp;&amp; i &lt; (data_sz - 1)) { /* 使用长度限制和时间限制来读取一块数据，多次调用底层读取函数好像是重复读取？ */ i += _rym_read_data(ctx, data_sz - 1); rt_thread_mdelay(5); } /* 超时导致长度较短，或者接收的数据包过长 */ if (i != (data_sz - 1)) return -RYM_ERR_DSZ; /* sanity check，第一个包index为0，反码为ff，错误的数据块序号 */ if (ctx-&gt;buf[1] != 0 || ctx-&gt;buf[2] != 0xFF) return -RYM_ERR_SEQ; /* 取出接收到的CRC校验码 */ recv_crc = (rt_uint16_t)(*(ctx-&gt;buf + data_sz - 2) &lt;&lt; 8) | *(ctx-&gt;buf + data_sz - 1); /* 计算接收到的buff内容的CRC，跳过关键字1Byte和数据块序号2Bytes，同时不包括最后2Bytes CRC */ cal_crc = CRC16(ctx-&gt;buf + 3, data_sz - 5); /* CRC校验错误 */ if (recv_crc != cal_crc) return -RYM_ERR_CRC; /* 解析数据块中的内容，获得传输文件的文件名等信息，On_Begin为应用层调用核心层时传入的函数，用于解析第一个数据块 */ if (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + 3, data_sz - 5) != RYM_CODE_ACK) return -RYM_ERR_CAN; return RT_EOK;} _rym_do_send_handshake 该函数用于Ymodem协议发送时的握手，该发送端等待接受端准备完毕，该发送端接收到接受端发送的代码C后，发送第一个数据块，接受端接收成功返回ACK和代码C后代表连接建立，执行发送任务时执行该函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static rt_err_t _rym_do_send_handshake( struct rym_ctx *ctx, int tm_sec){ enum rym_code code; rt_size_t i; rt_size_t data_sz; rt_uint8_t index = 0; rt_uint8_t getc_ack; /* 进入连接等待建立状态 */ ctx-&gt;stage = RYM_STAGE_ESTABLISHING; /* 握手时是第一个数据块，第一个数据块为小包128 Bytes */ data_sz = _RYM_SOH_PKG_SZ; /* 不断读取通讯设备，检测接受端是否发送代码C，超时为接收到代码C则代表握手失败 */ for (i = 0; i &lt; tm_sec; i++) { code = _rym_read_code(ctx, RYM_CHD_INTV_TICK); if (code == RYM_CODE_C) { break; } } if (i == tm_sec) { return -RYM_ERR_TMO; } /* 调用应用层传入的on_begin回调函数，该函数需要填充发送的第一个数据块所需的数据，仅填充数据部分 */ if (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + 3, data_sz - 5) != RYM_CODE_SOH) return -RYM_ERR_CODE; /* 将数据块关键字和索引（第一个数据块索引为0）封包发送 */ code = RYM_CODE_SOH; _rym_send_packet(ctx, code, index); /* 跳转函数在上层已经设置过了？不知道为什么再设置一遍，可能防止用户在on_begin中做了修改？？ */ rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind); /* 该getchar函数与readcode的不同之处是没有timeout，若下位机不给ACK，该函数将永远等待 */ getc_ack = _rym_getchar(ctx); /* 若返回的不是ACK，退出 */ if (getc_ack != RYM_CODE_ACK) { return -RYM_ERR_ACK; } /* 接受端返回ACK后需要再次发送代码C，代表接收成功，并准备好接收下一次传输（至少有一次真正的文件内容的传输） */ getc_ack = _rym_getchar(ctx); /* 若返回的不是C，退出 */ if (getc_ack != RYM_CODE_C) { return -RYM_ERR_ACK; } /* 握手成功，通讯建立 */ ctx-&gt;stage = RYM_STAGE_ESTABLISHED; return RT_EOK;} trans do_trans 该函数用于接受端接收数据块，是rym_recv_on_device函数的下层，负责状态控制，执行接收任务时执行该函数； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static rt_err_t _rym_do_trans(struct rym_ctx *ctx){ /* 握手成功后，需要向发送端发送ACK和代码C，表示接收成功，申请下一次接收 */ _rym_putchar(ctx, RYM_CODE_ACK); _rym_putchar(ctx, RYM_CODE_C); /* 连接状态建立 */ ctx-&gt;stage = RYM_STAGE_ESTABLISHED; /* 进入接收循环 */ while (1) { rt_err_t err; enum rym_code code; rt_size_t data_sz, i; /* 读取第一个关键字字节，获得即将要传输的字节大小，若关键字为EOT，代表传输结束 */ code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK); switch (code) { case RYM_CODE_SOH: data_sz = 128; break; case RYM_CODE_STX: data_sz = 1024; break; case RYM_CODE_EOT: return RT_EOK; default: return -RYM_ERR_CODE; }; /** * 传输data_sz指定大小的数据，存放到ctx的buf中，由应用层函数on_data进行数据的使用 * 返回code用于控制继续传输或者中止传输 */ err = _rym_trans_data(ctx, data_sz, &amp;code); if (err != RT_EOK) return err; switch (code) { /* Ymodem协议规定中止传输指令需要多次发送 */ case RYM_CODE_CAN: for (i = 0; i &lt; RYM_END_SESSION_SEND_CAN_NUM; i++) { _rym_putchar(ctx, RYM_CODE_CAN); } return -RYM_ERR_CAN; /* 发送应答，等待接收下一次传输 */ case RYM_CODE_ACK: _rym_putchar(ctx, RYM_CODE_ACK); break; default: break; }; }} do_send_trans 该函数用于发送端发送数据块，是rym_recv_on_device函数的下层，负责数据填充和发送，执行发送任务时执行该函数； 12345678910111213141516171819202122232425262728293031323334static rt_err_t _rym_do_send_trans(struct rym_ctx *ctx){ ctx-&gt;stage = RYM_STAGE_TRANSMITTING; enum rym_code code; rt_size_t data_sz; /* 数据块为第二个包，索引为1 */ rt_uint32_t index = 1; rt_uint8_t getc_ack; /* RTT可能只实现了发送小包？ */ data_sz = _RYM_SOH_PKG_SZ; while (1) { /* 由应用层负责填充数据 */ if (ctx-&gt;on_data &amp;&amp; ctx-&gt;on_data(ctx, ctx-&gt;buf + 3, data_sz - 5) != RYM_CODE_SOH) return -RYM_ERR_CODE; code = RYM_CODE_SOH; _rym_send_packet(ctx, code, index); index++; rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind); getc_ack = _rym_getchar(ctx); if (getc_ack != RYM_CODE_ACK) { return -RYM_ERR_ACK; } if (ctx-&gt;stage == RYM_STAGE_FINISHING) break; } return RT_EOK;} fin do_fin fin我觉得是finish。该函数用于实现发送端发送EOT信号之后的部分协议，执行接收任务时执行该函数； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static rt_err_t _rym_do_fin(struct rym_ctx *ctx){ enum rym_code code; rt_uint16_t recv_crc; rt_size_t i; rt_size_t data_sz; /* 状态更新为完成一次传输，但可能没有结束，因为Ymodem协议支持连续传输 */ ctx-&gt;stage = RYM_STAGE_FINISHING; /* 如果定义了on_end回调函数，执行该函数 */ if (ctx-&gt;on_end) ctx-&gt;on_end(ctx, ctx-&gt;buf + 3, 128); /* 在接收到第一次EOT的时候，接受端需要先返回一次NACK */ _rym_putchar(ctx, RYM_CODE_NAK); /* 然后进行监听，等待EOT的二次确认 */ code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK); /* 如果未收到二次确认，代表指令接收存在错误 */ if (code != RYM_CODE_EOT) return -RYM_ERR_CODE; /* 接收到二次确认，返回ACK和代码C */ _rym_putchar(ctx, RYM_CODE_ACK); _rym_putchar(ctx, RYM_CODE_C); /* 准备接收最后一个数据块 */ code = _rym_read_code(ctx, RYM_WAIT_PKG_TICK); if (code == RYM_CODE_SOH) { data_sz = _RYM_SOH_PKG_SZ; } else if (code == RYM_CODE_STX) { data_sz = _RYM_STX_PKG_SZ; } else return -RYM_ERR_CODE; /* 由于已经读掉一个关键字，因此size-1 */ i = _rym_read_data(ctx, _RYM_SOH_PKG_SZ - 1); if (i != (_RYM_SOH_PKG_SZ - 1)) return -RYM_ERR_DSZ; /* 最后一个数据块的索引必须为0，反码即为ff */ if (ctx-&gt;buf[1] != 0 || ctx-&gt;buf[2] != 0xFF) return -RYM_ERR_SEQ; /* CRC校验 */ recv_crc = (rt_uint16_t)(*(ctx-&gt;buf + _RYM_SOH_PKG_SZ - 2) &lt;&lt; 8) | *(ctx-&gt;buf + _RYM_SOH_PKG_SZ - 1); if (recv_crc != CRC16(ctx-&gt;buf + 3, _RYM_SOH_PKG_SZ - 5)) return -RYM_ERR_CRC; /** * 如果该数据包的数据部分不为零，代表EOT之后还要准备下一次传输 * 该数据包的内容为下一次传输的第一个包，包含文件名和size等信息 */ if (ctx-&gt;buf[3] != 0) { if (ctx-&gt;on_begin &amp;&amp; ctx-&gt;on_begin(ctx, ctx-&gt;buf + 3, data_sz - 5) != RYM_CODE_ACK) return -RYM_ERR_CAN; return RT_EOK; } /* 最后一个数据包的数据部分为0，代表传输结束，没有二次传输 */ ctx-&gt;stage = RYM_STAGE_FINISHED; /* 返回整次传输的最后一个ACK */ _rym_putchar(ctx, RYM_CODE_ACK); return RT_EOK;} do_send_fin 该函数用于实现发送端发送EOT信号之后由发送端完成的部分的协议，执行发送任务时执行该函数； 1234567891011121314151617181920212223242526272829303132333435363738static rt_err_t _rym_do_send_fin(struct rym_ctx *ctx){ enum rym_code code; rt_size_t data_sz; rt_uint8_t index = 0; rt_uint8_t getc_ack; data_sz = _RYM_SOH_PKG_SZ; rt_device_set_rx_indicate(ctx-&gt;dev, _rym_rx_ind); /* 发送EOT */ _rym_putchar(ctx, RYM_CODE_EOT); getc_ack = _rym_getchar(ctx); /* 如果没有接收到ACK */ if (getc_ack != RYM_CODE_NAK) { return -RYM_ERR_ACK; } /* 如果接收到ACK，再次发送EOT，进行二次确认 */ _rym_putchar(ctx, RYM_CODE_EOT); getc_ack = _rym_getchar(ctx); if (getc_ack != RYM_CODE_ACK) { return -RYM_ERR_ACK; } /* 二次确认成功，且读到代码C，可以发送最后一个数据包 */ getc_ack = _rym_getchar(ctx); if (getc_ack != RYM_CODE_C) { return -RYM_ERR_ACK; } /* 应用层填充最后一个数据包 */ if (ctx-&gt;on_end &amp;&amp; ctx-&gt;on_end(ctx, ctx-&gt;buf + 3, data_sz - 5) != RYM_CODE_SOH) return -RYM_ERR_CODE; /* 分包发送最后一个数据块 */ code = RYM_CODE_SOH; _rym_send_packet(ctx, code, index); /* 状态设置为传输结束 */ ctx-&gt;stage = RYM_STAGE_FINISHED; return RT_EOK;} 基础函数基础函数是整个核心层最底层的接口，与操作系统交换信息； _rym_read_code 该函数用于读取帧头关键字； 123456789101112131415161718192021222324static enum rym_code _rym_read_code( struct rym_ctx *ctx, rt_tick_t timeout){ /* 如果缓存中已有数据，直接取出一个就是关键字 */ if (rt_device_read(ctx-&gt;dev, 0, ctx-&gt;buf, 1) == 1) return (enum rym_code)(*ctx-&gt;buf); /* 如果缓存中没有 */ do { rt_size_t rsz; /* 等待信号量到达，接收一个关键字 */ if (rt_sem_take(&amp;ctx-&gt;sem, timeout) != RT_EOK) return RYM_CODE_NONE; /* 读取一个关键字 */ rsz = rt_device_read(ctx-&gt;dev, 0, ctx-&gt;buf, 1); if (rsz == 1) return (enum rym_code)(*ctx-&gt;buf); } while (1);} _rym_read_data 该函数用于从通讯端口设备中读取长度为len的数据块， 12345678910111213141516171819static rt_size_t _rym_read_data( struct rym_ctx *ctx, rt_size_t len){ /* 第一个字节是关键字，因此数据存储需要偏移一个字节 */ rt_uint8_t *buf = ctx-&gt;buf + 1; rt_size_t readlen = 0; /* 向系统拿取一定长度的数据 */ do { readlen += rt_device_read(ctx-&gt;dev, 0, buf + readlen, len - readlen); if (readlen &gt;= len) return readlen; } /* 信号量的等待设定超时机制 */ while (rt_sem_take(&amp;ctx-&gt;sem, RYM_WAIT_CHR_TICK) == RT_EOK); return readlen;} _rym_send_packet 该函数用于发送小包（128Bytes），仅作为发送端时使用，RTT可能仅实现了小包发送的发送端？ 123456789101112131415161718192021222324static rt_err_t _rym_send_packet( struct rym_ctx *ctx, enum rym_code code, rt_uint8_t index){ rt_uint16_t send_crc; rt_uint8_t index_inv = ~index; rt_size_t writelen = 0; /* 计算CRC，填充相关数据到数据块 */ send_crc = CRC16(ctx-&gt;buf + 3, _RYM_SOH_PKG_SZ - 5); ctx-&gt;buf[0] = code; ctx-&gt;buf[1] = index; ctx-&gt;buf[2] = index_inv; ctx-&gt;buf[131] = (rt_uint8_t)(send_crc &gt;&gt; 8); ctx-&gt;buf[132] = (rt_uint8_t)send_crc &amp; 0xff; /* 向操作系统内的设备发送数据块 */ do { writelen += rt_device_write(ctx-&gt;dev, 0, ctx-&gt;buf + writelen, _RYM_SOH_PKG_SZ - writelen); } while (writelen &lt; _RYM_SOH_PKG_SZ); return RT_EOK;} _rym_trans_data 该函数用于从操作系统接收数据块，为核心层所有接收数据块操作的最底层； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static rt_err_t _rym_trans_data( struct rym_ctx *ctx, rt_size_t data_sz, enum rym_code *code){ /** * 在调用该函数之前，一定且必须已经读取过关键字，获得接下来需要传输的数据块的大小 * 因此tran_size为2Bytes Index和~Index，data_size和2Bytes CRC Code */ const rt_size_t tsz = 2 + data_sz + 2; rt_uint16_t recv_crc; /* seq + data + crc */ rt_size_t i = _rym_read_data(ctx, tsz); if (i != tsz) return -RYM_ERR_DSZ; if ((ctx-&gt;buf[1] + ctx-&gt;buf[2]) != 0xFF) { return -RYM_ERR_SEQ; } /* As we are sending C continuously, there is a chance that the * sender(remote) receive an C after sending the first handshake package. * So the sender will interpret it as NAK and re-send the package. So we * just ignore it and proceed. */ if (ctx-&gt;stage == RYM_STAGE_ESTABLISHED &amp;&amp; ctx-&gt;buf[1] == 0x00) { *code = RYM_CODE_NONE; return RT_EOK; } ctx-&gt;stage = RYM_STAGE_TRANSMITTING; /* sanity check */ recv_crc = (rt_uint16_t)(*(ctx-&gt;buf + tsz - 1) &lt;&lt; 8) | *(ctx-&gt;buf + tsz); if (recv_crc != CRC16(ctx-&gt;buf + 3, data_sz)) return -RYM_ERR_CRC; /* congratulations, check passed. */ if (ctx-&gt;on_data) *code = ctx-&gt;on_data(ctx, ctx-&gt;buf + 3, data_sz); else *code = RYM_CODE_ACK; return RT_EOK;} 应用层（OTA应用）应用层实现于”ota_downloader/ymodem_ota.c”，是通过调用Ymodem核心层api进行OTA升级的应用实现。 Ymodem_ota的应用层包括三个部分： OTA开启一次升级，内部解析传入的，升级所需的参数，输出部分提示信息，调用核心层rym_recv_on_device()接口进行数据接收； on_begin，解析传入的第一个数据块，获得升级所需的Flash空间大小，检查Flash设备、空间是否满足升级需求，然后擦除； on_data，取出底层获得数据块，写入Flash指定位置； on_begin该函数解析第一个数据块，获得文件信息； 1234567891011121314151617181920212223242526272829303132333435363738394041static enum rym_code ymodem_on_begin(struct rym_ctx *ctx, rt_uint8_t *buf, rt_size_t len){ char *file_name, *file_size; /* 获得文件名称，文件名称以0结尾 */ file_name = (char *)&amp;buf[0]; /* 偏移文件名称长度+结尾0，首地址为文件大小信息 */ file_size = (char *)&amp;buf[rt_strlen(file_name) + 1]; /* 字符串转换获得文件大小 */ update_file_total_size = atol(file_size); rt_kprintf(\"Ymodem file_size:%d\\n\", update_file_total_size); /* 完成更新的文件部分尺寸 */ update_file_cur_size = 0; /* Get download partition information and erase download partition data */ /* 未找到下载分区 */ if ((dl_part = fal_partition_find(recv_partition)) == RT_NULL) { LOG_E(\"Firmware download failed! Partition (%s) find error!\", recv_partition); return RYM_CODE_CAN; } /* 文件大于下载分区 */ if (update_file_total_size &gt; dl_part-&gt;len) { LOG_E(\"Firmware is too large! File size (%d), '%s' partition size (%d)\", update_file_total_size, recv_partition, dl_part-&gt;len); return RYM_CODE_CAN; } LOG_I(\"Start erase. Size (%d)\", update_file_total_size); /* erase DL section */ if (fal_partition_erase(dl_part, 0, update_file_total_size) &lt; 0) { LOG_E(\"Firmware download failed! Partition (%s) erase error!\", dl_part-&gt;name); return RYM_CODE_CAN; } /* 擦除所需的Flash空间成功，下一个数据块接收后可以写入 */ return RYM_CODE_ACK;} on_data该函数实现数据块写入Flash； 12345678910111213static enum rym_code ymodem_on_data(struct rym_ctx *ctx, rt_uint8_t *buf, rt_size_t len){ /* 将解出的数据包写入到Flash */ if (fal_partition_write(dl_part, update_file_cur_size, buf, len) &lt; 0) { LOG_E(\"Firmware download failed! Partition (%s) write data error!\", dl_part-&gt;name); return RYM_CODE_CAN; } /* 每个数据块写入flash后，记录写入的size，作为下次写入的地址 */ update_file_cur_size += len; return RYM_CODE_ACK;} ota Firmware Over-the-Air Technology 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void ymodem_ota(uint8_t argc, char **argv){ struct rym_ctx rctx; /* 没有参数输入，使用默认配置（下载的分区名为“download”） */ if (argc &lt; 2) { recv_partition = DEFAULT_DOWNLOAD_PART; rt_kprintf(\"Default save firmware on download partition.\\n\"); } /* 使用-p选项加分区名参数自定义下载分区 */ else { const char *operator = argv[1]; if (!strcmp(operator, \"-p\")) { if (argc &lt; 3) { rt_kprintf(\"Usage: ymodem_ota -p &lt;partiton name&gt;.\\n\"); return; } else { /* change default partition to save firmware */ recv_partition = argv[2]; } }else{ rt_kprintf(\"Usage: ymodem_ota -p &lt;partiton name&gt;.\\n\"); return; } } rt_kprintf(\"Warning: Ymodem has started! This operator will not recovery.\\n\"); rt_kprintf(\"Please select the ota firmware file and use Ymodem to send.\\n\"); /** * 调用核心层接收数据接口 * rctx控制器包含状态变量，回调函数，buf，信号量，通讯端口设备 * rt_console_get_device()获得控制台使用的通讯端口设备，也可使用其他端口设备传输 * RT_DEVICE_OFLAG_RDWR：以读写模式打开设备，RT_DEVICE_FLAG_INT_RX：以中断模式接收 * ymodem_on_begin：解析第一个数据块 * ymodem_on_data：数据块写入 * NULL：未定义on_end函数 * RT_TICK_PER_SECOND：timeout为1 */ if (!rym_recv_on_device(&amp;rctx, rt_console_get_device(), RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX, ymodem_on_begin, ymodem_on_data, NULL, RT_TICK_PER_SECOND)) { /* 接收和存储数据成功 */ rt_kprintf(\"Download firmware to flash success.\\n\"); rt_kprintf(\"System now will restart...\\r\\n\"); /* wait some time for terminal response finish */ rt_thread_delay(rt_tick_from_millisecond(200)); /* Reset the device, Start new firmware */ /* 系统将会重启，Download分区中的内容将在启动后由Bootloader搬运到App分区，然后从App分区执行 */ extern void rt_hw_cpu_reset(void); rt_hw_cpu_reset(); /* wait some time for terminal response finish */ rt_thread_delay(rt_tick_from_millisecond(200)); } else { /* wait some time for terminal response finish */ /* 接收或存储数据失败 */ rt_thread_delay(RT_TICK_PER_SECOND); rt_kprintf(\"Update firmware fail.\\n\"); } return;}","link":"/2020/07/15/Ymodem-RTT/"},{"title":"Markdown &amp; Typora","text":"Markdown Typora 开始Markdown 标题 Markdown Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、[Stack Exchange](https://baike.baidu.com/item/Stack Exchange/13777796)、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 资料来源于百度百科 Markdown常用于记录总结、文档编写，但除了文字，它还包括图片、多级标题、引用、代码块、公式块、流程图、表格等表现形式 在知乎有markdown 在CSDN有markdown Typora Typora是一款轻便简洁的Markdown编辑器，但重点是免费，当然也好用。 开始MarkdownMarkdown的语法很多，且方言众多，挺头疼的，但只要掌握一些基础的通用的语法，足以编写一些简洁优秀的文档了。 标题Markdown中的标题类似于word中的标题样式，不同等级的标题具有不同大小的字体，并且具有相应的等级效应，在生成目录的时候有所体现，Markdown中的标题具有超链接式的跳转能力，可在不同的标题之间快速跳转。 123456# 标题一## 标题二··##### 标题五###### 标题六 Markdown一般支持最多六级标题","link":"/2020/11/16/Markdown-Typora/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"系统配置","slug":"系统配置","link":"/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"},{"name":"Windows Terminal","slug":"Windows-Terminal","link":"/tags/Windows-Terminal/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"美化","slug":"美化","link":"/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Powerline","slug":"Powerline","link":"/tags/Powerline/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"疑难杂症","slug":"疑难杂症","link":"/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ymodem","slug":"Ymodem","link":"/tags/Ymodem/"},{"name":"协议","slug":"协议","link":"/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"文件传输","slug":"文件传输","link":"/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"源码阅读","slug":"源码阅读","link":"/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"软件推荐","slug":"软件推荐","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"}],"categories":[]}